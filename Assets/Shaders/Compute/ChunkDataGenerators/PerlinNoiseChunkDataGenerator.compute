#pragma kernel GenerateData
#include "../Noise/ClassicNoise2D.hlsl"
#include "../Structs/VoxelData.compute"
#include "../Structs/HeightAndMaterialHashAssociation.compute"
#include "../Structs/RectPrism.compute"
#include "../BufferHandlers/ChunkSizePrisms.compute"

StructuredBuffer<int3> LocalChunksPositions;
RWStructuredBuffer<VoxelData> ChunkData;
int Octaves;
float Persistence;
float Frequency;
float Amplitude;
float MaxHeight;
float MinHeight;

[numthreads(1, 256, 1)]
void GenerateData (uint3 id : SV_DispatchThreadID)
{    
    RectPrism chunkRectPrism = GetChunkVoxelsPrism();
    if (id.y >= chunkRectPrism.Volume)
    { 
        return;
    }
    
    RectPrism chunkOffsetRectPrism = GetChunkVoxelsPrism();
    
    int3 localChunkPos = LocalChunksPositions[id.x];
    int3 localVoxelPos = IndexToPoint(chunkRectPrism, id.y);
    int3 globalChunkPos = localChunkPos * chunkOffsetRectPrism.Size;
    int3 globalVoxelPos = globalChunkPos + localVoxelPos;
    int i = id.x * chunkRectPrism.Volume + id.y;
     
    float heightThreshold = MinHeight + ClassicNoise(float2(globalVoxelPos.x, globalVoxelPos.z) / Frequency) * MaxHeight;
    
        //, Amplitude, Frequency, Persistence, Octaves) * MaxHeight;
    
    //float heightThreshold = sin((float)globalVoxelPos.x / 16) * 8;
    
    VoxelData voxel;
    voxel.Volume = 0;
    voxel.MaterialHash = GetMaterialKeyHashByHeight(globalVoxelPos.y);
    
    if (globalVoxelPos.y < heightThreshold)
    {
        voxel.Volume = 1;
    } 
    
    ChunkData[i] = voxel;
}
