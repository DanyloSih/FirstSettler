#pragma kernel GenerateMesh

#include "MarchingCubesBase.compute"
#include "Structs/VoxelData.compute"
#include "Structs/VertexInfo.compute"
#include "Structs/RectPrism.compute"
#include "Structs/DebugData.compute"
#include "BufferHandlers/ChunkSizePrisms.compute"

#define MAX_VERTICES_PER_MARCH 15

StructuredBuffer<VoxelData> ChunkData;
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<VertexInfo> VerticesInfo;
float Surface;

float GetOffset(float v1, float v2)
{
    float delta = v2 - v1;
    return (delta == 0.0f) ? Surface : (Surface - v1) / delta;
}

[numthreads(1, 256, 1)]
void GenerateMesh(uint3 id : SV_DispatchThreadID)
{
    RectPrism chunkVoxelsPrism = GetChunkVoxelsPrism();
    RectPrism chunkCubesPrism = GetChunkCubesPrism();
    uint cubeIndex = id.y;
    
    if (cubeIndex >= chunkCubesPrism.Volume)
    {
        return;
    }
    
    uint3 cubePos = IndexToPoint(chunkCubesPrism, cubeIndex);
    uint voxelIndex = PointToIndex(chunkVoxelsPrism, cubePos);
    int materialHash = ChunkData[voxelIndex].MaterialHash;
    
    int chunkStartId = chunkCubesPrism.Volume * 15 * id.x;
    int meshPartIndexStart = chunkStartId + cubeIndex * 15;
    float offset = 0.0f;
    int i = 0;
    
    for (i = 0; i < 15; i++)
    {
        VertexInfo vi;
        vi.IsCorrect = false;
        vi.MaterialHash = materialHash;
        VerticesInfo[meshPartIndexStart + i] = vi;
        Vertices[meshPartIndexStart + i] = 0;
    }
    
    float Cubes[8];
    float3 localEdgeVertexBuffer[12];
        
    Cubes[0] = ChunkData[PointToIndex(chunkVoxelsPrism, uint3(cubePos.x, cubePos.y, cubePos.z))].Volume;
    Cubes[1] = ChunkData[PointToIndex(chunkVoxelsPrism, uint3(cubePos.x + 1, cubePos.y, cubePos.z))].Volume;
    Cubes[2] = ChunkData[PointToIndex(chunkVoxelsPrism, uint3(cubePos.x + 1, cubePos.y + 1, cubePos.z))].Volume;
    Cubes[3] = ChunkData[PointToIndex(chunkVoxelsPrism, uint3(cubePos.x, cubePos.y + 1, cubePos.z))].Volume;
    Cubes[4] = ChunkData[PointToIndex(chunkVoxelsPrism, uint3(cubePos.x, cubePos.y, cubePos.z + 1))].Volume;
    Cubes[5] = ChunkData[PointToIndex(chunkVoxelsPrism, uint3(cubePos.x + 1, cubePos.y, cubePos.z + 1))].Volume;
    Cubes[6] = ChunkData[PointToIndex(chunkVoxelsPrism, uint3(cubePos.x + 1, cubePos.y + 1, cubePos.z + 1))].Volume;
    Cubes[7] = ChunkData[PointToIndex(chunkVoxelsPrism, uint3(cubePos.x, cubePos.y + 1, cubePos.z + 1))].Volume;
    
    int flagIndex = 0;
    for (i = 0; i < 8; i++) 
        if (Cubes[i] <= Surface) 
            flagIndex |= 1 << i;
    
    int edgeFlags = CubeEdgeFlags[flagIndex];
    if (edgeFlags == 0)
        return;
    
    float3 edgeVert = 0;
    for (i = 0; i < 12; i++)
    {
        if ((edgeFlags & (1 << i)) != 0)
        {
            offset = GetOffset(Cubes[EdgeConnection[i][0]], Cubes[EdgeConnection[i][1]]);
            
            edgeVert.x = cubePos.x + VertexOffset[EdgeConnection[i][0]][0] + offset * EdgeDirection[i][0];
            edgeVert.y = cubePos.y + VertexOffset[EdgeConnection[i][0]][1] + offset * EdgeDirection[i][1];
            edgeVert.z = cubePos.z + VertexOffset[EdgeConnection[i][0]][2] + offset * EdgeDirection[i][2];
            localEdgeVertexBuffer[i] = edgeVert;
        }
    }
    
    for (int b = 0; b < 15; b++)
    {
        int globalB = meshPartIndexStart + b;
        int triangleEdge = TriangleConnectionTable[flagIndex][b / 3];
        
        if (triangleEdge < 0)
            break;
            
        VertexInfo vi;
        vi.IsCorrect = true;
        vi.MaterialHash = triangleEdge;
        VerticesInfo[globalB] = vi;
        
        //Vertices[globalB] = localEdgeVertexBuffer[TriangleConnectionTable[flagIndex][b]];
        Vertices[globalB] = -666;
    }
}

