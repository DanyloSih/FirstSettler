#pragma kernel GenerateMesh

#include "MarchingCubesBase.compute"

#include "Structs/VoxelData.compute"
#include "Structs/IndexAndMaterialHash.compute"
#include "Structs/EssentialChunkInfo.compute"
#include "Structs/RectPrism.compute"
#include "BufferHandlers/ChunkSizePrisms.compute"

StructuredBuffer<VoxelData> ChunkData;
StructuredBuffer<int3> ChunksLocalPositions;
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<IndexAndMaterialHash> Indices;
int MaxVerticesPerMarch;
int ChunksCount;
int GapValue;
float Surface;

float GetOffset(float v1, float v2)
{
    float delta = v2 - v1;
    return (delta == 0.0f) ? Surface : (Surface - v1) / delta;
}

EssentialChunkInfo GetEssentialChunkInfo(int chunkId, int localVoxelId, RectPrism chunkVoxelsPrism, RectPrism chunkCubesPrism)
{
    EssentialChunkInfo essentialChunkInfo;
    essentialChunkInfo.IsOutOfBounds = localVoxelId >= chunkVoxelsPrism.Volume;
    
    if (essentialChunkInfo.IsOutOfBounds)
    {
        return essentialChunkInfo;
    }
        
    essentialChunkInfo.LocalChunkPosition = ChunksLocalPositions[chunkId];
    essentialChunkInfo.LocalVoxelPosition = IndexToPoint(chunkVoxelsPrism, localVoxelId);
    essentialChunkInfo.LocalCubePosition = IndexToPoint(chunkCubesPrism, localVoxelId);
    essentialChunkInfo.GlobalChunkPosition = essentialChunkInfo.LocalChunkPosition * chunkCubesPrism.Size;
    essentialChunkInfo.GlobalVoxelPosition = essentialChunkInfo.GlobalChunkPosition + essentialChunkInfo.LocalVoxelPosition;
    essentialChunkInfo.GlobalCubePosition = essentialChunkInfo.GlobalChunkPosition + essentialChunkInfo.LocalCubePosition;
    essentialChunkInfo.LocalVoxelId = localVoxelId;
    essentialChunkInfo.ChunkFirstVoxelId = chunkId * chunkVoxelsPrism.Volume;
    essentialChunkInfo.GlobalVoxelId = essentialChunkInfo.ChunkFirstVoxelId + localVoxelId;
    return essentialChunkInfo;
}

[numthreads(1, 256, 1)]
void GenerateMesh(uint3 id : SV_DispatchThreadID)
{
    RectPrism chunkVoxelsPrism = GetChunkVoxelsPrism();
    RectPrism chunkCubesPrism = GetChunkCubesPrism();
    
    EssentialChunkInfo chunkInfo = GetEssentialChunkInfo(id.x, id.y, chunkVoxelsPrism, chunkCubesPrism);
    if (chunkInfo.IsOutOfBounds)
    {
        return;
    }
    
    int3 localCubePos = chunkInfo.LocalCubePosition;
    int voxelIndex = chunkInfo.LocalVoxelId;
    int firstVertexId = (chunkCubesPrism.Volume * id.x) + (id.y * MaxVerticesPerMarch);
    int materialHash = ChunkData[voxelIndex].MaterialHash;
    float offset = 0.0f;
    int i, triangleId;
    
    IndexAndMaterialHash tr;
    tr.MaterialHash = materialHash;
    for (i = 0; i < 15; i++)
    {
        tr.Index = GapValue;
        Indices[firstVertexId + i] = tr;
    }
    
    float Cubes[8];
    float3 localEdgeVertexBuffer[12];
    
    Cubes[0] = ChunkData[chunkInfo.ChunkFirstVoxelId + PointToIndex(chunkVoxelsPrism, float3(localCubePos.x, localCubePos.y, localCubePos.z))].Volume;
    Cubes[1] = ChunkData[chunkInfo.ChunkFirstVoxelId + PointToIndex(chunkVoxelsPrism, float3(localCubePos.x + 1, localCubePos.y, localCubePos.z))].Volume;
    Cubes[2] = ChunkData[chunkInfo.ChunkFirstVoxelId + PointToIndex(chunkVoxelsPrism, float3(localCubePos.x + 1, localCubePos.y + 1, localCubePos.z))].Volume;
    Cubes[3] = ChunkData[chunkInfo.ChunkFirstVoxelId + PointToIndex(chunkVoxelsPrism, float3(localCubePos.x, localCubePos.y + 1, localCubePos.z))].Volume;
    Cubes[4] = ChunkData[chunkInfo.ChunkFirstVoxelId + PointToIndex(chunkVoxelsPrism, float3(localCubePos.x, localCubePos.y, localCubePos.z + 1))].Volume;
    Cubes[5] = ChunkData[chunkInfo.ChunkFirstVoxelId + PointToIndex(chunkVoxelsPrism, float3(localCubePos.x + 1, localCubePos.y, localCubePos.z + 1))].Volume;
    Cubes[6] = ChunkData[chunkInfo.ChunkFirstVoxelId + PointToIndex(chunkVoxelsPrism, float3(localCubePos.x + 1, localCubePos.y + 1, localCubePos.z + 1))].Volume;
    Cubes[7] = ChunkData[chunkInfo.ChunkFirstVoxelId + PointToIndex(chunkVoxelsPrism, float3(localCubePos.x, localCubePos.y + 1, localCubePos.z + 1))].Volume;
    
    int flagIndex = 0;
    
    for (i = 0; i < 8; i++)
    {
        if (Cubes[i] <= Surface)
        {
            flagIndex |= 1 << i;
        }
    }
    
    int edgeFlags = CubeEdgeFlags[flagIndex];
    if (edgeFlags == 0)
        return;
    
    float3 edgeVert;
    
    for (i = 0; i < 12; i++)
    {
        if ((edgeFlags & (1 << i)) != 0)
        {
            offset = GetOffset(Cubes[EdgeConnection[i][0]], Cubes[EdgeConnection[i][1]]);
            
            edgeVert.x = chunkInfo.LocalCubePosition.x + VertexOffset[EdgeConnection[i][0]][0] + offset * EdgeDirection[i][0];
            edgeVert.y = chunkInfo.LocalCubePosition.y + VertexOffset[EdgeConnection[i][0]][1] + offset * EdgeDirection[i][1];
            edgeVert.z = chunkInfo.LocalCubePosition.z + VertexOffset[EdgeConnection[i][0]][2] + offset * EdgeDirection[i][2];
            localEdgeVertexBuffer[i] = edgeVert;
        }
    }
    
    float3 vertex1, vertex2, vertex3;
    int subLoopId = 0;
    
    for (i = 0; i < 5; i++)
    {
        subLoopId = 3 * i;
        if (TriangleConnectionTable[flagIndex][subLoopId] < 0)
            break;
        
        triangleId = firstVertexId + i;
        
        tr.Index = triangleId;
        Indices[triangleId] = tr;
        
        tr.Index = triangleId + 1;
        Indices[triangleId + 1] = tr;
        
        tr.Index = triangleId + 2;
        Indices[triangleId + 2] = tr;
        
        vertex1 = localEdgeVertexBuffer[TriangleConnectionTable[flagIndex][subLoopId]];
        vertex2 = localEdgeVertexBuffer[TriangleConnectionTable[flagIndex][subLoopId + 1]];
        vertex3 = localEdgeVertexBuffer[TriangleConnectionTable[flagIndex][subLoopId + 2]];
        
        Vertices[triangleId] = vertex1;
        Vertices[triangleId + 1] = vertex2;
        Vertices[triangleId + 2] = vertex3;
    }
}
