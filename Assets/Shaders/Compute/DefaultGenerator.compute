#pragma kernel CSMain
#include "PerlinNoise2D.compute"
#include "RectPrism.compute"

struct VoxelData
{
    float Volume;
    int MaterialHash;
};

struct HeightAndMaterialHashAssociation
{
    float Height;
    int MaterialHash;
};

RWStructuredBuffer<VoxelData> ChunkData;
StructuredBuffer<HeightAndMaterialHashAssociation> HeightAndHashAssociations;
StructuredBuffer<HeightAndMaterialHashAssociation> MinMaxAssociations;
StructuredBuffer<RectPrism> ChunkSizeAndChunkOffsetAndGlobalAndLoadingAreaRectPrisms;
int ChunkGlobalPositionX;
int ChunkGlobalPositionY;
int ChunkGlobalPositionZ;
int AssociationsCount;
int Octaves;
float Persistence;
float Frequency;
float Amplitude;
float MaxHeight;
float MinHeight;

RectPrism GetChunkRectPrism()
{
    return ChunkSizeAndChunkOffsetAndGlobalAndLoadingAreaRectPrisms[0];
}

RectPrism GetChunkOffsetRectPrism()
{
    return ChunkSizeAndChunkOffsetAndGlobalAndLoadingAreaRectPrisms[1];
}

RectPrism GetGlobalGenerationAreaRectPrism()
{
    return ChunkSizeAndChunkOffsetAndGlobalAndLoadingAreaRectPrisms[2];
}

RectPrism GetChunksLoadingAreaRectPrism()
{
    return ChunkSizeAndChunkOffsetAndGlobalAndLoadingAreaRectPrisms[3];
}

int GetMaterialKeyHashByHeight(float height)
{
    HeightAndMaterialHashAssociation min = MinMaxAssociations[0];
    HeightAndMaterialHashAssociation max = MinMaxAssociations[1];
    
    if (height >= max.Height)
    {
        return max.MaterialHash;
    }
    else if (height <= min.Height)
    {
        return min.MaterialHash;
    }
    else
    {  
        int result = 0;
        if (AssociationsCount == 0)
        {
            return result;
        }
        
        for (int i = AssociationsCount - 1; i >= 0; i--)
        {
            HeightAndMaterialHashAssociation association = HeightAndHashAssociations[i];
            
            if (association.Height > height)
            {
                result = association.MaterialHash;
                break;
            }
        }
        
        return result;
    }
}

[numthreads(1, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    RectPrism chunkRectPrism = GetChunkRectPrism();
    RectPrism chunkOffsetRectPrism = GetChunkOffsetRectPrism();
    RectPrism globalGenerationAreaRectPrism = GetGlobalGenerationAreaRectPrism();
    RectPrism loadAreaRectPrism = GetChunksLoadingAreaRectPrism();
    
    int3 chunkDataSize = chunkRectPrism.Size;
    int3 chunkOffsetSize = chunkOffsetRectPrism.Size;
    
    int3 localChunkPos = int3(id.x / chunkDataSize.x, id.y / chunkDataSize.y, id.z / chunkDataSize.z);
    int3 localVoxelPos = int3(id.x % chunkDataSize.x, id.y % chunkDataSize.y, id.z % chunkDataSize.z);
    
    int i = PointToIndex(loadAreaRectPrism, localChunkPos) * chunkRectPrism.Volume 
        + PointToIndex(chunkRectPrism, localVoxelPos);
    
    int3 globalPos = int3(
        ChunkGlobalPositionX + localVoxelPos.x + (localChunkPos.x * chunkOffsetSize.x),
        ChunkGlobalPositionY + localVoxelPos.y + (localChunkPos.y * chunkOffsetSize.y),
        ChunkGlobalPositionZ + localVoxelPos.z + (localChunkPos.z * chunkOffsetSize.z));
    
    float heightThreshold = CalculatePerlinNoise2D(
        float2(globalPos.x, globalPos.z), Amplitude, Frequency, Persistence, Octaves) * MaxHeight;
    
    
    VoxelData voxel;
    voxel.Volume = 0;
    voxel.MaterialHash = GetMaterialKeyHashByHeight(globalPos.y);
    
    if (globalPos.y < heightThreshold)
    {
        voxel.Volume = 1;
    } 
    
    ChunkData[i] = voxel;
}
